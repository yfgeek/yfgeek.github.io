---
title: JavaScript创建对象的七种模式
date: 2016-10-11 13:16:14
tags: Web
categories: Web
---

<section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMA-262把<span style="color: rgb(0, 128, 255);">对象</span>定义为：”无需属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说明对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把ECMAScript的对象想象成散列表：无非就是一组名对值，其中值可以是数据或函数。&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义对象最简单的方式就是创建一个<span style="color: rgb(0, 128, 255);">Object</span>的实例，然后再为他添加属性和方法，如下所示：</span></p></section><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">var</span> person = <span class="" style="color: rgb(0, 0, 136);">new</span> <span class="" style="color: rgb(102, 0, 102);">Object</span>();、</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person.name = <span class="" style="font-size: 12px; color: rgb(0, 136, 0);">"liubei"</span>;</span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person.age = <span class="" style="font-size: 12px; color: rgb(0, 102, 102);">29</span>;<br>person.job = <span class="" style="font-size: 12px; color: rgb(0, 136, 0);">"shayemuyou"</span>;<br><br>person.sayName = <span class="" style="font-size: 12px; color: rgb(0, 0, 136);">function</span><span class="" style="font-size: 12px; color: rgb(102, 0, 102);">()</span>{
 &nbsp; &nbsp;<br>&nbsp; alert(<span class="" style="font-size: 12px; color: rgb(0, 0, 136);">this</span>.name);<br>}</span></code></pre><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子创建了一个名为<span style="color: rgb(0, 128, 255);">person</span>的对象，并为他添加了三个属性和一个方法。其中<span style="color: rgb(0, 128, 255);">sayName()</span>方法用于显示name属性，<span style="color: rgb(0, 128, 255);">this.name</span>将被解析为person.name，早期的开发人员经常使用这个模式来创建对象，后来对象字面量的方法成了创建对象的首选模式，上面的例子用对象字面量的语法可以写成如下这样：</span></p></section><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">var</span> person = {
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;name:<span class="" style="color: rgb(0, 136, 0);">"liubei"</span>,
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;age:<span class="" style="color: rgb(0, 102, 102);">29</span>,
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;job:<span class="" style="color: rgb(0, 136, 0);">"shayemuyou"</span>,
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;sayName:<span class="" style="color: rgb(0, 0, 136);">function</span><span class="" style="color: rgb(102, 0, 102);">()</span>{
 &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;alert(<span class="" style="color: rgb(0, 0, 136);">this</span>.name);
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp;}<br>}</span></code></pre><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子中的<span style="color: rgb(0, 128, 255);">person</span>对象和前面的对象是一样的，都有相同的属性和方法。&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然<span style="color: rgb(0, 128, 255);">Object</span>构造函数或者对象字面量的方法都可以用来创建单个对象，但是这些方法有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个方法，人们开始使用工厂模式的一种变体。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47); font-size: 14px;"><strong><span style="color: rgb(247, 92, 47);">一、工厂模式</span></strong></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程</strong></span><span style="color: rgb(136, 136, 136);">。考虑到ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下所示：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span> <span class="" style="box-sizing: border-box;">createPerson</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">(name, age, job)</span>{</span>
 <br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">&nbsp; var</span> o = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> <span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">Object</span>();<br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.name = name; <br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.age = age; <br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.job = job;<br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.sayName = <span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">()</span>{</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; alert(<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.name);
 &nbsp; &nbsp;<br>&nbsp; }<br> &nbsp;<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> o;<br>}<br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">var</span> person1 = createPerson(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"wei"</span>,<span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">25</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"software"</span>);<br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">var</span> person2 = createPerson(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"bu"</span>,<span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">25</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"software"</span>);</span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数<span style="color: rgb(0, 128, 255);">createPerson()</span>能够根据接受的参数来构建一个包含所有必要信息的<span style="color: rgb(0, 128, 255);">Person</span>对象。可以多次调用这个函数，每次都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎么样知道这是哪个对象类型。</span><br></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>二、构造函数模式</strong></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像Array、Object这样的原生构造函数，在运行时会自动出现在执行环境中。此外，我们可以创建自定义个构造函数，从而定义自定义类型的属性和方法。例如，我们可以使用构造函数重写上个例子：</span></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">function</span> Person<span class="" style="color: rgb(102, 0, 102);">(name, age, job)</span>{<span class="" style="color: rgb(0, 0, 136);"> &nbsp; &nbsp;<br> &nbsp; &nbsp;this</span>.name = name;<br><span class="" style="color: rgb(0, 0, 136);"> &nbsp; &nbsp;this</span>.age = age;<br><span class="" style="color: rgb(0, 0, 136);"> &nbsp; &nbsp;this</span>.job = job;<br><span class="" style="color: rgb(0, 0, 136);"> &nbsp; &nbsp;this</span>.sayName = <span class="" style="color: rgb(0, 0, 136);">function</span><span class="" style="color: rgb(102, 0, 102);">()</span>{
 &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;alert(<span class="" style="color: rgb(0, 0, 136);">this</span>.name);
 &nbsp; &nbsp;<br> &nbsp; &nbsp;&nbsp; &nbsp;}<br>}<br><span class="" style="color: rgb(0, 0, 136);">var</span> person1 = <span class="" style="color: rgb(0, 0, 136);">new</span> Person(<span class="" style="color: rgb(0, 136, 0);">"wei"</span>,<span class="" style="color: rgb(0, 102, 102);">25</span>,<span class="" style="color: rgb(0, 136, 0);">"software"</span>);<br><span class="" style="color: rgb(0, 0, 136);">var</span> person2 = <span class="" style="color: rgb(0, 0, 136);">new</span> Person(<span class="" style="color: rgb(0, 136, 0);">"bu"</span>,<span class="" style="color: rgb(0, 102, 102);">25</span>,<span class="" style="color: rgb(0, 136, 0);">"software"</span>);</span></code></pre><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，<span style="color: rgb(0, 128, 255);">Person()</span>函数取代了<span style="color: rgb(0, 128, 255);">createPerson()</span>函数，我们注意到<span style="color: rgb(0, 128, 255);">Person()</span>与<span style="color: rgb(0, 128, 255);">createPerson()</span>的不同之处在于：</span></p><ul class="list-paddingleft-2"><li><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">没有显式的创建对象</span></p></li><li><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">直接将属性和方法赋值给this对象</span></p></li><li><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">没有return语句&nbsp;</span></p></section></li></ul><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还应该<span style="color: rgb(247, 92, 47);"><strong>注意到函数名Person使用的是大写字母P</strong></span>。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴了其他OO语言，主要是为了区别于ECMAScript中的其他函数。因为构造函数本身也是函数，只不过可以创建对象而已。&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要创建一个<span style="color: rgb(0, 128, 255);">Person</span>实例，必须使用<span style="color: rgb(0, 128, 255);">new</span>操作符。以上这种方式会经过以下四个步骤：&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;1、创建一个新对象</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;2、将构造函数的作用域赋给新对象（因此this指向这个新对象）</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;3、执行构造函数中的代码</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;4、返回新对象&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面例子的最后，<span style="color: rgb(0, 128, 255);">person1</span>和<span style="color: rgb(0, 128, 255);">person2</span>分别保存着<span style="color: rgb(0, 128, 255);">Person</span>的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。如下：</span></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">console.<span class="" style="color: rgb(0, 0, 136);">log</span>(person1.constructor == Person); &nbsp; &nbsp; <span class="" style="color: rgb(136, 0, 0);">//true</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">console.<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">log</span>(person2.constructor == Person); &nbsp; &nbsp; <span class="" style="font-size: 14px; color: rgb(136, 0, 0);">//true</span></span></code></p></pre></section><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象的<span style="color: rgb(0, 128, 255);">constructor</span>属性最初是用来标识对象类型的。但是，提到检测对象类型，还是<span style="color: rgb(0, 128, 255);">instanceof</span>操作符比较可靠一些。我们在这个例子中创建的对象都是<span style="color: rgb(0, 128, 255);">Object</span>对象的实例，也是<span style="color: rgb(0, 128, 255);">Person</span>对象的实例，这一点通过instanceof操作符可以验证。</span></p><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(102, 0, 102);">console</span>.log(person1 <span class="" style="color: rgb(0, 0, 136);">instanceof</span> Object); &nbsp; &nbsp; <span class="" style="color: rgb(0, 136, 0);">//</span><span class="" style="color: rgb(0, 102, 102);">true</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person1 <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">instanceof</span> Person); &nbsp; &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span><span class="" style="font-size: 14px; color: rgb(0, 102, 102);">true</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person2 <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">instanceof</span> Object); &nbsp; &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span><span class="" style="font-size: 14px; color: rgb(0, 102, 102);">true</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person2 <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">instanceof</span> Person); &nbsp; &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span><span class="" style="font-size: 14px; color: rgb(0, 102, 102);">true</span></span></code></p></pre></section><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义的构造函数意味着将来可以将他的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，<span style="color: rgb(0, 128, 255);">person1</span>和<span style="color: rgb(0, 128, 255);">person2</span>之所以同是<span style="color: rgb(0, 128, 255);">Object</span>的实例，是因为所有的对象都继承自Object。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数的主要问题，就是每个方法都要在实例上重新创建一遍，造成内存浪费。在前面的例子中，<span style="color: rgb(0, 128, 255);">person1</span>和<span style="color: rgb(0, 128, 255);">person2</span>都有一个名为<span style="color: rgb(0, 128, 255);">sayName()</span>的方法，但是两个方法不是同一<span style="color: rgb(0, 128, 255);">Function</span>的实例。不要忘了ECMAScript中的函数也是对象，因此每定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数可以这样定义：</span></p><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">function</span> Person<span class="" style="color: rgb(102, 0, 102);">(name, age, job)</span>{</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.name = name; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.age = age; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.job = job; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.sayName = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">new</span> <span class="" style="font-size: 14px; color: rgb(102, 0, 102);">Function</span>(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"alert(this.name);"</span>) &nbsp; </span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(136, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;//与声明函数在逻辑上是等价的</span>}</span></code></p></pre></section><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个角度来看构造函数，更容易看明白每个<span style="color: rgb(0, 128, 255);">Person</span>实例都会包含一个不同的<span style="color: rgb(0, 128, 255);">Function</span>实例的本质。说明白些，会导致不同的作用域链和标识符解析，但是创建<span style="color: rgb(0, 128, 255);">Function</span>新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证实这一点。</span></p><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">alert(person1<span class="" style="color: rgb(68, 68, 68);">.sayName</span> == person2<span class="" style="color: rgb(68, 68, 68);">.sayName</span>)<span class="" style="color: rgb(136, 0, 0);">; &nbsp;//false</span></span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，创建两个完成同样任务的<span style="color: rgb(0, 128, 255);">Function</span>实例的确没有必要；况且有<span style="color: rgb(0, 128, 255);">this</span>对象在，根本不用在执行代码前就把函数绑定到特定的对象上。因此，可以像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</span></p><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">function</span> Person<span class="" style="color: rgb(102, 0, 102);">(name, age, job)</span>{</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.name = name; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.age = age; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.job = job; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.sayName = sayName;</span></code></p><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">}</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">function</span> sayName<span class="" style="font-size: 14px; color: rgb(102, 0, 102);">()</span>{</span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"> &nbsp; &nbsp;alert(<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.name);
}</span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做解决了多个函数解决相同问题的问题，但是有产生了新的问题，在全局作用域中实际上只被某个对象调用，这让全局对象有点名不副实。更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在这些问题可以使用原型模式来解决。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>三、原型模式</strong></span></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="text-align: justify;"><br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="text-align: justify; color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们创建的每个函数都有一个<span style="text-align: justify; color: rgb(0, 128, 255);">prototype</span>（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的实例就是让所有实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象的实例信息，而是可以将这些信息直接添加到原型对象中，如下所示：</span><br></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">function</span> Person<span class="" style="color: rgb(102, 0, 102);">()</span>{<br>}<br>Person.prototype.name = <span class="" style="color: rgb(0, 136, 0);">"wei"</span>;<br>Person.prototype.age = <span class="" style="color: rgb(0, 102, 102);">27</span>;<br>Person.prototype.job = <span class="" style="color: rgb(0, 136, 0);">"Software"</span>;<br>Person.prototype.sayName = <span class="" style="color: rgb(0, 0, 136);">function</span><span class="" style="color: rgb(102, 0, 102);">()</span>{
 &nbsp; &nbsp;<br> &nbsp;alert(<span class="" style="color: rgb(0, 0, 136);">this</span>.name);<br>}<br> <br><span class="" style="color: rgb(0, 0, 136);">var</span> person1 = <span class="" style="color: rgb(0, 0, 136);">new</span> Person();</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person1.sayName(); &nbsp; &nbsp; &nbsp;<span class="" style="font-size: 14px; color: rgb(136, 0, 0);">//"wei"</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);"><br>var</span> person2 = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">new</span> Person();</span></code></p><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person2.sayName(); &nbsp; &nbsp; &nbsp;<span class="" style="font-size: 14px; color: rgb(136, 0, 0);">//"wei"</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><br><span style="font-size: 14px;">alert(person1.sayName == person2.sayName);</span></code></p></pre></section></section></section></section></section></section></section></section></section><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="box-sizing: border-box;"><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，我们将<span style="color: rgb(0, 128, 255);">sayName()</span>方法和所有的属性直接添加在了<span style="color: rgb(0, 128, 255);">Person</span>的<span style="color: rgb(0, 128, 255);">prototype</span>属性中，构造函数变成了空函数。即便如此，我们仍然可以通过构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但是与构造函数不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，<span style="color: rgb(0, 128, 255);">person1</span>和<span style="color: rgb(0, 128, 255);">person2</span>访问的都是同一组属性和同一个<span style="color: rgb(0, 128, 255);">sayName()</span>函数。要理解原型模式的工作原理，就必须先理解ECMAScript中原型对象的性质。&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型对象的本性由于篇幅太长将会在下一章节详细分析。上面我们说了原型模式的好处，接下来我们来看一下原型模式的缺点。原型模式省略了为构造函数传递参数的这一环节，结果所有实例在默认情况下都具有相同的属性值。这会在某些程度上带来一种不便，这并不是原型模式最大的问题，因为如果我们想为一个通过原型模式创建的对象添加属性时，添加的这个属性就会屏蔽原型对象的保存的同名属性。换句话说，就是添加的这个属性会阻止我们去访问原型中的属性，但并不会改变原型中的属性。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式最大的问题是由其共享的本质所导致的。原型中所有的属性被很多实例共享，这种共享对函数非常合适，对包含基本值的属性也说的过去，但是对引用类型的属性值来说问题就比较突出了，下面我们来看一个例子：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="box-sizing: border-box;">function</span> Person(){
}
Person.prototype = { &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="box-sizing: border-box; color: rgb(0, 136, 0);">constructor</span>:Person, &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="box-sizing: border-box; color: rgb(0, 136, 0);">name</span>:<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"wei"</span>, &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="box-sizing: border-box; color: rgb(0, 136, 0);">age</span>:<span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">29</span>, &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="box-sizing: border-box; color: rgb(0, 136, 0);">friends</span>:[<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"乾隆"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"康熙"</span>], &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="box-sizing: border-box; color: rgb(0, 136, 0);">sayName</span>:<span class="" style="box-sizing: border-box;">function</span>(){
 &nbsp; &nbsp; &nbsp; &nbsp;alert(<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.name);
 &nbsp; &nbsp;}
}<br><span class="" style="box-sizing: border-box;">var</span> person1 = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Person();<br><span class="" style="box-sizing: border-box;">var</span> person2 = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Person();
person1.friends.push(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"嬴政"</span>);<br><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">console</span>.log(person1.friends); &nbsp; <span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">//</span>[<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"乾隆"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"康熙"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"嬴政"</span>]<br><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">console</span>.log(person2.friends); &nbsp; <span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">//</span>[<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"乾隆"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"康熙"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"嬴政"</span>]<br><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">console</span>.log(person1.friends === person2.friends); &nbsp; <span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">//</span><span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">true</span></span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"></span></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，<span style="color: rgb(0, 128, 255);">Person.prototype</span>对象有一个名为<span style="color: rgb(0, 128, 255);">friends</span>的属性，该属性包含一个字符串数组。然后创建了两个<span style="color: rgb(0, 128, 255);">Person</span>的实例，接着修改<span style="color: rgb(0, 128, 255);">person1.friends</span>引用的数组，向数组中添加一个字符串，由于数组存在于<span style="color: rgb(0, 128, 255);">Person.prototype</span>中而不是<span style="color: rgb(0, 128, 255);">person1</span>中，所以<span style="color: rgb(0, 128, 255);">person2.friends</span>也会被修改。但是一般每个对象都是要有属于自己的属性的，所以我们很少看到有人单独使用原型模式来创建对象。</p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p></section></section><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>四、组合使用构造函数模式和原型模式</strong></span><span style="color: rgb(136, 136, 136);"></span><br></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义类型最常见的方式就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子：</span></p></section></section><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"></span></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><section class="" data-tools="135编辑器" data-id="87859" style="   box-sizing: border-box; "><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; "><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">function Person(name, age){ &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.name = name; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.age = age; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.friends = [<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"乾隆"</span>,<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"康熙"</span>];</span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">}</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">Person.prototype = { &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 136, 0);">&nbsp;&nbsp;&nbsp;&nbsp;constructor</span>:Person, &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 136, 0);">&nbsp;&nbsp;&nbsp;&nbsp;sayName</span>:function(){</span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"> &nbsp; &nbsp; &nbsp; &nbsp;alert(<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.name);
 &nbsp; &nbsp;}</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">}</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">var person1 = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">new</span> Person(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"wei"</span>,<span class="" style="font-size: 14px; color: rgb(0, 102, 102);">29</span>);</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">var person2 = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">new</span> Person(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"bu"</span>,<span class="" style="font-size: 14px; color: rgb(0, 102, 102);">25</span>);</span></code></p><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person1.friends.push(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"嬴政"</span>);</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person1.friends); &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span>[<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"乾隆"</span>, <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"康熙"</span>, <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"嬴政"</span>]</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person2.friends); &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span>[<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"乾隆"</span>, <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"康熙"</span>]</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person1.friends === person2.friends); &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span><span class="" style="font-size: 14px; color: rgb(0, 102, 102);">false</span></span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">console</span>.log(person1.sayName === person2.sayName); &nbsp; <span class="" style="font-size: 14px; color: rgb(0, 136, 0);">//</span><span class="" style="font-size: 14px; color: rgb(0, 102, 102);">true</span></span></code></p></pre></section></section><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性<span style="color: rgb(0, 128, 255);">constructor</span>和方法<span style="color: rgb(0, 128, 255);">sayName()</span>则是在原型中定义的。所以修改了<span style="color: rgb(0, 128, 255);">person1.friends</span>并不会改变<span style="color: rgb(0, 128, 255);">person2.friends</span>，因为他们分别引用了不同的数组。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种构造函数与原型模式混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用的一种默认形式。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>五、动态原型模式</strong></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常的困惑。动态原型模式就是用来解决这个问题的一个方案，它把所有的信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否要初始化原型。来看一个例子：</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"></span></p><section data-role="outer" label="Powered by 135editor.com" style="font-family: 微软雅黑;"><pre class="" name="code" style=" white-space: nowrap;  overflow-y: hidden; overflow-x: auto; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136);">function</span> Person<span class="" style="color: rgb(102, 0, 102);">(name, age)</span>{</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.name = name; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.age = age; &nbsp; &nbsp;</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">&nbsp;&nbsp;&nbsp;&nbsp;this</span>.friends = [<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"乾隆"</span>,<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"康熙"</span>]; &nbsp; &nbsp;<span class="" style="font-size: 14px; color: rgb(136, 0, 0);">//注意if语句</span></span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">if</span>(<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">typeof</span> <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.sayName!=<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"function"</span>){<br>&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.sayName = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">function</span><span class="" style="font-size: 14px; color: rgb(102, 0, 102);">()</span>{ <br>&nbsp;&nbsp;&nbsp;&nbsp;alert(<span class="" style="font-size: 14px; color: rgb(0, 0, 136);">this</span>.name);
 &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</span></code><p style="white-space: normal;"><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">}</span></code><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="font-size: 14px; color: rgb(0, 0, 136);">var</span> person1 = <span class="" style="font-size: 14px; color: rgb(0, 0, 136);">new</span> Person(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"wei"</span>,<span class="" style="font-size: 14px; color: rgb(0, 102, 102);">29</span>);</span></code></p><code class="" style=" display: block; background: transparent; color: inherit ; ; ; ; ; ; ; ; "><span style="font-size: 14px;">person1.friends.push(<span class="" style="font-size: 14px; color: rgb(0, 136, 0);">"嬴政"</span>);
person1.sayName();</span></code></pre></section><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意构造函数代码中的if语句，这里只在<span style="color: rgb(0, 128, 255);">sayName()</span>方法不存在的情况下才会将它添加到原型中。这断代码只有在第一次调用构造函数的时候才会被执行。此后，原型已经被初始化，不需要再做什么修改。不过要记住，这里所做的修改能立即在所有实例中得到反映。因此，这种方法可以说确实非常完美。其中if语句检查的是初始化之后应该存在的任何方法和属性–不必再用一大堆if来检查每个属性和方法，只检查其中一个即可。对于采用这样模式创建的对象，还可以使用<span style="color: rgb(0, 128, 255);">instanceof</span>操作符来确定他的类型。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有的实例与新原型之间的联系。</strong></span><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><strong><span style="color: rgb(247, 92, 47);">六、寄生构造函数模式</span></strong></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><br></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，在上述几种模式都不适合的情况下可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，但从表面看，这个函数又很像典型的构造函数。来看一个例子：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span> <span class="" style="box-sizing: border-box;">Person</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">(name, age, job)</span>{</span><br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">&nbsp; var</span> o = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> <span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">Object</span>();<br>&nbsp; o.name = name;<br>&nbsp; o.age = age;
 &nbsp; &nbsp;<br>&nbsp; o.job = job;
 &nbsp; &nbsp;<br>&nbsp; o.sayName = <span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">()</span>{</span><br>&nbsp; alert(<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.name);
 &nbsp; &nbsp;} &nbsp; &nbsp;<br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;"> &nbsp; &nbsp; &nbsp;return</span> o;
}<br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">var</span> person = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Person(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"wei"</span>,<span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">29</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"banzhuan"</span>);
person.sayName(); &nbsp; <span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//"wei"</span></span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，<span style="color: rgb(0, 128, 255);">Person</span>函数创建了一个对象，并以相应的属性和方法初始化该对象，然后返回了这个对象。除了使用<span style="color: rgb(0, 128, 255);">new</span>操作符把使用的包装函数叫做构造函数之外，这个模式和工厂模式并没有多大的区别。构造函数在不返回值的情况下，会默认返回新对象的实例。而通过在构造函数的末尾添加一个<span style="color: rgb(0, 128, 255);">return</span>语句，可以重写调用构造函数时返回的值。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个模式可以在特殊的情况下来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span> <span class="" style="box-sizing: border-box;">SpecialArray</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">()</span>{</span><span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;"><br> &nbsp; &nbsp;//创建数组</span><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;"><br> &nbsp; &nbsp;var</span> values = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> <span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">Array</span>(); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//添加值</span><br> &nbsp; &nbsp;values.push.apply(values,<span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">arguments</span>); &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;<span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//添加方法</span><br> &nbsp; &nbsp;values.toPipedString = <span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">()</span>{</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.join(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"|"</span>);<br>} &nbsp; &nbsp;<br> <br> <span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">&nbsp; &nbsp;//返回数组</span><br> <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">&nbsp; &nbsp;return</span> values;<br> }<br><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">var</span> colors = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> SpecialArray(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"red"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"blue"</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"green"</span>);<br>console.log(colors.toPipedString());<span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//red|blue|green</span></span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，我们创建了一个名为<span style="color: rgb(0, 128, 255);">SpecialArray</span>的构造函数。在这个函数的内部，首先创建了一个数组，然后<span style="color: rgb(0, 128, 255);">push()</span>方法初始化了数组的值。随后又给数组实例添加了<span style="color: rgb(0, 128, 255);">toPipedString()</span>方法，用来返回以竖线分隔的数组值。最后将数组以函数的形式返回。接着，我们调用了<span style="color: rgb(0, 128, 255);">SpecialArray</span>构造函数，传入了初始化的值，并调用了<span style="color: rgb(0, 128, 255);">toPipedString()</span>方法。</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于寄生构造函数模式，有一点需要声明：首先，返回的对象与构造函数或者构造函数的原型没有任何关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象的类型。由于存在这一的问题，我们建议在可以使用其他模式的情况下不要使用这种模式。<br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: center; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(247, 92, 47);"><strong>七、稳妥构造函数模式</strong></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);"><br></span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓<span style="color: rgb(247, 92, 47);"><strong>稳妥对象，是指没有公共属性，而且其方法也不引用this对象</strong></span>。稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的<span style="color: rgb(0, 128, 255);">Person</span>构造函数重写如下：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span> <span class="" style="box-sizing: border-box;">Person</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">(name, age, job)</span>{</span><span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;"> &nbsp; &nbsp;<br> &nbsp; &nbsp;//创建要返回的新对象</span><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">&nbsp; &nbsp; <br>&nbsp; &nbsp;var</span> o = <span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> <span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">Object</span>(); <br> &nbsp;<br><span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;"> &nbsp; &nbsp;//可以在这里定义私有变量和函数 &nbsp; &nbsp;<br> &nbsp; &nbsp;<br> &nbsp; &nbsp;//添加方法</span><br>&nbsp; &nbsp;o.sayName = <span class="" style="box-sizing: border-box;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">function</span><span class="" style="color: rgb(102, 0, 102); box-sizing: border-box;">()</span>{</span>&nbsp;<br>&nbsp; &nbsp; &nbsp;&nbsp;alert(<span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.name);
 &nbsp; &nbsp;<br>&nbsp; &nbsp;}; &nbsp; &nbsp;<br><br> &nbsp; &nbsp;<span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//返回对象</span><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;"><br>&nbsp; &nbsp;return</span> o;<br> &nbsp; &nbsp;}</span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，在以这种模式创建的对象中，除了使用<span style="color: rgb(0, 128, 255);">sayName()</span>方法之外，没有其他办法访问<span style="color: rgb(0, 128, 255);">name</span>的值。可以像下面使用稳妥的<span style="color: rgb(0, 128, 255);">Person</span>构造函数：</span></p><pre class="" name="code" style=" white-space: nowrap; word-wrap: break-word; box-sizing: border-box;  overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em ; ; ; ; ; ; ; ; ; ; ; ; ; "><code class="" style=" display: block; background: transparent; color: inherit; box-sizing: border-box ; ; ; ; ; ; ; "><span style="font-size: 14px;"><span class="" style="color: rgb(0, 0, 136); box-sizing: border-box;">var</span> person =Person(<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"weiqi"</span>,<span class="" style="color: rgb(0, 102, 102); box-sizing: border-box;">22</span>,<span class="" style="color: rgb(0, 136, 0); box-sizing: border-box;">"banzhuan"</span>);<br>person.sayName(); &nbsp; <span class="" style="color: rgb(136, 0, 0); box-sizing: border-box;">//weiqi</span></span></code></pre><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，变量<span style="color: rgb(0, 128, 255);">person</span>中保存的是一个稳妥对象，而除了<span style="color: rgb(0, 128, 255);">sayName()</span>方法外，没有别的方式可以访问其他数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得他非常适合在某些安全执行环境–例如，ADsafe(www.adsafe.org)提供的环境下使用。&nbsp;</span></p><p style="line-height: 1.75em; text-align: justify; margin-top: 10px; font-size: 14px; color: rgb(161, 161, 161); white-space: normal;"><span style="color: rgb(136, 136, 136);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(247, 92, 47);"><strong>注意：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。</strong></span></span></p>
 
>转自：http://blog.csdn.net/u014346301/article/details/52204967